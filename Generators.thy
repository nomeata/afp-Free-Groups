header {* Generators *}

theory "Generators"
imports
   "~~/src/HOL/Algebra/Group"
   "~~/src/HOL/Algebra/Lattice"
begin

text {* This theory is not specific to Free Groups and could be moved to a more 
general place. It defines the subgroup generated by a set of generators and
that homomorphisms agree on the generated subgroup if they agree on the
generators. *}

notation subgroup (infix "\<le>" 80)

subsection {* The subgroup generated by a set *}

text {* The span of a set of subgroup generators, i.e. the generated subgroup, can
be defined inductively or as the intersection of all subgroups containing the
generators. Here, we define it inductively and proof the equivalence *}

inductive_set (in group) gen_span :: "'a set \<Rightarrow> 'a set" ("\<guillemotleft>_\<guillemotright>" 81)
  for gens :: "'a set"
where gen_one [intro!, simp]: "\<one> \<in> \<guillemotleft>gens\<guillemotright>"
    | gen_gens: "x \<in> gens \<Longrightarrow> x \<in> \<guillemotleft>gens\<guillemotright>"
    | gen_inv: "x \<in> \<guillemotleft>gens\<guillemotright> \<Longrightarrow> inv x \<in> \<guillemotleft>gens\<guillemotright>"
    | gen_mult: "\<lbrakk> x \<in> \<guillemotleft>gens\<guillemotright>; y \<in> \<guillemotleft>gens\<guillemotright> \<rbrakk> \<Longrightarrow>  x \<otimes> y \<in> \<guillemotleft>gens\<guillemotright>"

(*
definition (in group) gen_subgroup :: "'a set \<Rightarrow> ('a,'b) monoid_scheme" ("\<guillemotleft>_\<guillemotright>" 80)
 where "\<guillemotleft>gens\<guillemotright> = G (|carrier := \<guillemotleft>gens\<guillemotright> |)"
*)

lemma (in group) gen_span_closed:
  assumes "gens \<subseteq> carrier G"
  shows "\<guillemotleft>gens\<guillemotright> \<subseteq> carrier G"
proof (* How can I do this in one "by" line? *)
  fix x
  from assms show "x \<in> \<guillemotleft>gens\<guillemotright> \<Longrightarrow> x \<in> carrier G"
    by -(induct rule:gen_span.induct, auto)
qed

lemma (in group) gen_subgroup_is_subgroup: 
      "gens \<subseteq> carrier G \<Longrightarrow> \<guillemotleft>gens\<guillemotright> \<le> G"
by(rule subgroupI)(auto intro:gen_span.intros simp add:gen_span_closed)

lemma (in group) gen_subgroup_is_smallest_containing:
  assumes "gens \<subseteq> carrier G"
    shows "\<Inter>{H. H \<le> G \<and> gens \<subseteq> H} = \<guillemotleft>gens\<guillemotright>"
proof
  show "\<guillemotleft>gens\<guillemotright> \<subseteq> \<Inter>{H. H \<le> G \<and> gens \<subseteq> H}"
  proof(rule Inf_greatest)
    fix H
    assume "H \<in> {H. H \<le> G \<and> gens \<subseteq> H}"
    hence "H \<le> G" and "gens \<subseteq> H" by auto
    show "\<guillemotleft>gens\<guillemotright> \<subseteq> H"
    proof
      fix x
      from `H \<le> G` and `gens \<subseteq> H`
      show "x \<in> \<guillemotleft>gens\<guillemotright> \<Longrightarrow> x \<in> H"
       unfolding subgroup_def
       by -(induct rule:gen_span.induct, auto)
    qed
  qed
next
  from `gens \<subseteq> carrier G`
  have "\<guillemotleft>gens\<guillemotright> \<le> G" by (rule gen_subgroup_is_subgroup)
  moreover
  have "gens \<subseteq> \<guillemotleft>gens\<guillemotright>" by (auto intro:gen_span.intros)
  ultimately
  show "\<Inter>{H. H \<le> G \<and> gens \<subseteq> H} \<subseteq> \<guillemotleft>gens\<guillemotright>"
    by(auto intro:Inter_lower)
qed

subsection {* Generators and homomorphisms *}

text {* Two homorphisms agreeing on some elements agree on the span of those elements.*}

lemma hom_uniqe_on_span:
  assumes "group G"
      and "group H"
      and "gens \<subseteq> carrier G"
      and "h \<in> hom G H"
      and "h' \<in> hom G H"
      and "\<forall>g \<in> gens. h g = h' g"
  shows "\<forall>x \<in> group.gen_span G gens. h x = h' x"
proof
  interpret G: group G by fact
  interpret H: group H by fact
  interpret h: group_hom G H h by unfold_locales fact
  interpret h': group_hom G H h' by unfold_locales fact

  fix x
  from `gens \<subseteq> carrier G` have "\<guillemotleft>gens\<guillemotright> \<subseteq> carrier G" by (rule G.gen_span_closed)
  with assms show "x \<in> \<guillemotleft>gens\<guillemotright> \<Longrightarrow> h x = h' x" apply -
  proof(induct rule:G.gen_span.induct)
    case (gen_mult x y)
      hence x: "x \<in> carrier G" and y: "y \<in> carrier G" and
            hx: "h x = h' x" and hy: "h y = h' y" by auto
      thus "h (x \<otimes>\<^bsub>G\<^esub> y) = h' (x \<otimes>\<^bsub>G\<^esub> y)" by simp
  qed auto
qed

subsection {* Sets of generators *}

text {* There is no definition for @{text gens} is a generating set of
@{text G}. This is easily expressed by @{text "\<guillemotleft>gens\<guillemotright> = carrier G"}. *}

text {* The following is application of @{text hom_uniqe_on_span} on a generating
  set of the whole group. *}


lemma (in group) hom_uniqe_by_gens:
  assumes "group H"
      and gens: "\<guillemotleft>gens\<guillemotright> = carrier G"
      and "h \<in> hom G H"
      and "h' \<in> hom G H"
      and "\<forall>g \<in> gens. h g = h' g"
  shows "\<forall>x \<in> carrier G. h x = h' x"
proof
  fix x

  from gens have "gens \<subseteq> carrier G" by (auto intro:gen_span.gen_gens)
  with assms and group_axioms have r: "\<forall>x \<in> group.gen_span G gens. h x = h' x"
    by -(erule hom_uniqe_on_span, auto)
  with gens show "x \<in> carrier G \<Longrightarrow> h x = h' x" by auto
qed

subsection {* Product of a list of group elements *}

text {* Not strictly related to generators of groups, this is still a general
group concept and not related to FreeGroups. *}

abbreviation (in monoid) m_concat
  where "m_concat \<equiv> foldl (op \<otimes>) \<one>"

lemma (in monoid) m_concat_closed[simp]:
 "set l \<subseteq> carrier G \<Longrightarrow> m_concat l \<in> carrier G"
  by (induct l rule:rev_induct, auto)

lemma (in monoid) m_concat_append[simp]:
  assumes "set a \<subseteq> carrier G"
      and "set b \<subseteq> carrier G"
  shows "m_concat (a@b) = m_concat a \<otimes> m_concat b"
using assms
by(induct b rule:rev_induct)(auto simp add: m_assoc)

lemma (in monoid) m_concat_cons[simp]:
  "\<lbrakk> x \<in> carrier G ; set xs \<subseteq> carrier G \<rbrakk> \<Longrightarrow> m_concat (x#xs) = x \<otimes> m_concat xs"
by(induct xs rule:rev_induct)(auto simp add: m_assoc)


end
